<?php
/**
 * Транзакции (рассмотрим пример при отправке денег на другую карту)
 * ТОЛЬКО НА InnoBD (MyISAM не поддерживает транзакции)
 *
 * 1) Снимаются деньги с вашей карточки
 * 2) Пополняется счет другой карточки
 * 3) Записываются логи операции
 *
 * И возможна такая ситуация, когда деньги с карты снялись и выключился свет (или пробоемы на сервере).
 * Транзакция - 3 запроса берутся в оболочку
 * Запрос считается выполненым тогда, когда все 3 запроса выполнились
 */

{ НАЧАТЬ ТРАНЗАКЦИЮ
    1) Снимаются деньги с вашей карточки
    2) Пополняется счет другой карточки
    3) Записываются логи операции
} ЗАКОНЧИТЬ ТРАНЗАКЦИЮ (УСПЕШНО ИЛИ ОБОРВАТЬ)

    if () {
    do something
        if (что то не нравится) {
            Оборвать транзакцию
        }
    }

    START TRANSACTION;


    COMMIT; // Подтвердить
    ROLLBACK; // Отменить операцию


/*
    Serializable (упорядочиваемость)[править | править код]
    Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга,
    каждая выполняется так, как будто параллельных транзакций не существует.
    Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения».
*/
Core::$DB_NAME = 'test';

q("SET SESSION tx_isolation='SERIALIZABLE'");
DB::_()->begin_transaction();
// выбираем запись с `id` = 1 (кот)
/**
 * SERIALIZABLE и FOR UPDATE подрозумевает, что строка с `id` = 1 будет заблокирована для чтения
 * второй скрипт не сможет сделать выборку (будет ждать пока первый закончит и дойдет до DB::_()->commit();)
 */
$res = q("
    SELECT `name`
    FROM `pets`
    WHERE `id` = 1
    FOR UPDATE 
");
sleep(10); // скрипт ждет 10 сек.
// вставляет выбранную запись в БД (кот2)
$row = $res->fetch_assoc();
q("
    INSERT INTO `pets` SET
    `name` = '".$row['name']."2'
");
// запись с `id` = 1 (кот) -> заменит на 'Кошка'
q("
    UPDATE `pets` SET
    `name` = 'Кошка'
    WHERE `id` = 1
");
DB::_()->commit();

// В то время пока у нас в первом скрипте sleep(10); // скрипт ждет 10 сек.
// Запускаем второй скрипт (ОН ВЫПОЛНИТЬСЯ ТОЛЬКО ТОГДА, КОГДА ОПЕРАЦИЯ В ПЕРВОМ СКРИПТЕ БУДЕТ ЗАВЕРШЕНА)
Core::$DB_NAME = 'test';

q("SET SESSION tx_isolation='SERIALIZABLE'");
DB::_()->begin_transaction();
// выбираем запись с `id` = 1 (Кошка)
$res = q("
    SELECT `name`
    FROM `pets`
    WHERE `id` = 1
    FOR UPDATE 
");

// вставляет выбранную запись в БД (Кошка3)
$row = $res->fetch_assoc();
q("
    INSERT INTO `pets` SET
    `name` = '".$row['name']."3'
");

DB::_()->commit();

/**
 * ситуация получить деньги в банкомате
 * максимум 2 человека могут подать один запрос в одно и то же время
 * но берем запас 5 человек
 * тогда если даже 3 человека подадут запрос они получат по 1000 и в банкомате останется еще 2000
 * тогда мы можем применить не жетскую изолированность, а например (REPEATABLE READ)
 * тем самым не будем ставить запрос остальных клиентов в очередь, и нагружать БД
 * выполнение запросов происходит быстрее
 * ЧЕМ БОЛЬШЕ БЕЗОПАСНОСТЬ - ТЕМ МЕНЬШЕ СКОРОСТЬ
 */
$q = получить деньги в банкомате
if (денег в банкомате < 5000) {
    блокируем (денег не достаточно)
} else {
    - деньги банкомата
    + деньги клиенту
    залогировали операцию
}

/**
    Полнотекстовый индекс:
    Полнотекстовый индекс — словарь, в котором перечислены все слова и указано, в каких местах они встречаются.
    Если мы осуществляем поиск сразу по двум полям, то необходимо делать составной индекс по этим самым двум полям.
 * Ищет быстрее, чем LIKE, но ищет слово целиком
 */

q("
    SELECT * FROM `aa_blog` WHERE
    MATCH (title,text)
    AGAINST ('ddos' IN NATURAL LANGUAGE MODE)
");

/**
 * Проверяем релевантность слова в поиске
 */

q("
    SELECT *, MATCH (title,text) AGAINST ('pHp' IN NATURAL LANGUAGE MODE) as `score`
    FROM `aa_blog`
    WHERE MATCH (title,text)
    AGAINST ('pHp' IN NATURAL LANGUAGE MODE)

");
//  '+php -html*' при чем * после html означает, что нам не важно окончание (html5 тоже попадет в выборку)
q("
    SELECT *
    FROM `aa_blog`
    WHERE MATCH (title,text)
        AGAINST ('+php -html*' IN BOOLEAN MODE) // +php (встречается в тесте) -html* (выбрать там где не встречается html)
");















